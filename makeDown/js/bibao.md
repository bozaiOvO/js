# 闭包

## 前言：早上起来突然想到一个问题,以前大家都想拥有武林秘籍努力练习，而现在，网上的这么多资源都算是一本本武林秘籍了，都这样暴露出来，可是努力练习而成为大师的又有几个呢，人都是懒惰的。希望自己步子再大一点，不要在原地只知道感叹时间的流逝和自己的渺小，不能再这样了！

## 什么是闭包呢？

+ 回掉函数都是闭包
+ 阮大的说法：闭包就是能够读取其他函数内部变量的函数。

## 闭包的作用？

 +　我需要从外部引用函数内的局部变量！局部变量无法共享和长久的保存，而全局变量可能造成变量污染，所以我们希望有一种机制既可以长久的保存变量又不会造成全局污染。
 
 +　把变量的值始终保持在内存里。
 
 ## 那究竟啥是闭包呢？

 ``` 举个栗子。

    function a1(){
        var count = 0;
        function a2(){
            count += 1;
            console.log(count)
        }
        return a2
    }
    
    var a3 = a1()
    a3()//1
    a3()//2




 ```

 + 在这个栗子里，你会发现这个count并没有清除掉，这就是一个闭包，那不是应该在`var a3 = a1()` 这个时候就应该清除掉这个a1的执行环境吗，是因为这个a1返回的是一个函数，而这个函数里面引用了a1里面的count，如果清除a1，那么这个count就会寻找不到，所以这个时候内存分配了空间保留了a1。对就是这么简单...如果你不懂为啥`var a3 = a1()`就要清除a1，那继续往下看。


## 执行上下文。
js是一个单线程语言，意味着他不可以同时做两个事情，**他只可以在同一时间内做一个事情**，当js开始执行的时候，他会进入一个全局环境，函数的每次调用都会创建一个新的执行环境。也就是每一次，js只可以执行一件事情，浏览器是用“栈”来维护上下文，遵循的就是后进先出！就比如一个盒子装满了东西，那最后放进去的东西肯定就是最先出来的.而程序一开始，就将全局对象放到栈中，执行函数的时候，就把要执行的函数压入到栈内，而全局对象就压到了栈底，也可以说，全局对象就是在栈底！当执行的函数执行完之后，再把函数弹出，接着执行下面的。

### 执行上下文的分类：

+ 全局执行上下文。
+ 函数执行上下文。

### 举个栗子

```
var a = 1;
function fn1() {
  function fn2() {
   console.log(a);
 }
 fn2();
}
fn1();

```

分为以下几步
+ 1.js执行把全局的上下文入栈。
+ 2.遇到fn1() 执行这个函数，创建该函数执行上下文，入栈，执行fn1。
+ 3.遇到fn2() 执行创建自己的执行上下文，入栈，执行fn2。
+ 4.fn2()在执行中并没有创建新的上下文，代码执行完毕，fn2出栈。
+ 5.fn2出战后执行fn1，fn1也不再创建新的上下文，代码执行完毕后，fn1出战。然后执行剩下的全局上下文。

### 五个重点
+ 单线程。
+ 同步执行。所有的执行上下文都得等到栈顶的执行之后才能顺序执行
+ 只有一个全局执行上下文。
+ 函数上下文是无限制的。
+ 每次函数被调用时都会创建新的执行上下文，包括调用自己.

### 回头看`var a3 = a1()`就要清除a1
```
    function a1(){
        var count = 0;
        function a2(){
            count += 1;
            console.log(count)
        }
        return a2
    }
    
    var a3 = a1()
    a3()//1
    a3()//2





```
分为以下几步：
+ js执行，全局上下文入栈。
+ 执行到a1()，a1进栈，然后并没有执行其他函数，也就是并没有创建新的执行上下文，把a1的执行结果也就是reutrn了一个a2，赋予给了a3。按照我们的理解，此时没有创建新的执行上下文，那应该销毁对不对？这个先放着。
+ 执行a3()，a3执行的就是被return 出来的a2()，执行a2的时候需要打印一个count，如果是a1被销毁的情况下，那这个count是找不到的！！！因为a1被销毁了。所以a1是不可以被销毁的，因为如果a1被销毁，那a3依赖于a1就没法执行。所以回到那句话：因为这个a1返回的是一个函数，而这个函数里面引用了a1里面的count，如果清除a1，那么这个count就会寻找不到，所以这个时候内存分配了空间保留了a1。~

### 深入了解执行上下文。

#### 执行上下文的构成
每个执行上下文都可以分为一个有三个属性的对象。
```
executionContextObj = {
    scopeChain: { /* 变量对象（variableObject）+ 所有父执行上下文的变量对象*/ }, 
    variableObject: { /*函数 arguments/参数，内部变量和函数声明 */ }, 
    this: {} 
}

```
执行上下文的产生

在JavaScript解释器内部，每次调用执行上下文，分为两个阶段

#### 创建阶段（函数被调用，但是没有执行里面的代码）
+ 设置`[[scope]]`属性的值
+ 设置变量对象VO的值，创建变量，函数以及参数。
+ 设置this。

#### 执行阶段
+ 被激活，开始执行内部代码。

#### 创建阶段执行顺序一些提升。

+ 根据函数参数，创建并初始化arguments object。
+ 扫描上下文的函数声明，对于找到的函数声明，将函数名和函数引用存入VO中，如果VO中已经有同名函数，那么就进行覆盖。
+ 扫面上下文的变量声明：对于找到的每个变量声明，将变量名存入VO中，并且将变量的值初始化为undefined。如果变量的名字已经在变量对象里存在，不会进行任何操作并继续扫描。

#### 举个栗子

```
    function a1(num){
        var count = 0 + num;
        var a3 = function (){

        }
        function a2(){
            count += 1;
            console.log(count)
        }
        return a2
    }
    a1(1)
    
```
a1()执行的时候，会创建成这样
```
executionContextObj = {
    scopeChain: { /* 变量对象（variableObject）+ 所有父执行上下文的变量对象*/ }, 
    variableObject: {
         /*函数 arguments/参数，内部变量和函数声明 */
         argunments:{
            0:1,
            length:1
        } ,
        num:1,
         a2: pointer to function a2(),
         count :undefined
         a3:undefined

     }, 
    this: {} 
}



```
创建完成后，执行依次对变量赋值。

### 理解提升。
#### 又是一个栗子。
```
(function() {
    console.log(typeof name); 
    console.log(typeof another); 
    var name = 'Abby',
        another = function() {
            return 'Lucky';
        };
    function name() {
        return 'Abby';
    }
    console.log(typeof name); 
    console.log(typeof another); 
}()); 


```

+ 想一想你觉得他是怎么执行的呢~？