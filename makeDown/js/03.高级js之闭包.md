# js 波仔

+ 闭包是面试必问的问题，也是每一个js开发者必须知道的，以前我总觉得他玄之又玄，其实，也就那么回事，没啥玄的。

## 先说说js执行上下文
+ js是一个单线程语言，意味着他不可以同时做两个事情，他只可以在同一时间内做一个事情，当js开始执行的时候，他会进入一个全局环境，函数的每次调用都会创建一个新的执行环境。也就是每一次，js只可以执行一件事情，浏览器是用“栈”来维护上下文，遵循的就是后进先出！就比如一个盒子装满了东西，那最后放进去的东西肯定就是最先出来的.而程序一开始，就将全局对象放到栈中，执行函数的时候，就把要执行的函数压入到栈内，而全局对象就压到了栈底，也可以说，全局对象就是在栈底！当执行的函数执行完之后，再把函数弹出，接着执行下面的。

### 先看个栗子。
```javascript
function a(){
    var n =1 
    n++ 
    console.log(n)
}
a()//2
a()


```
执行第一次a，势必是2，这大家都知道，但是在执行一次呢？还会是2！为啥呢？因为n是a函数的内部变量，a执行完毕后，这个n就销毁了被弹出了，不存在了。所以，你在执行一次，他又重新创建一个n，又执行一次++，还是2.

### 在举个栗子

```javascript
var a = 1;
function fn1() {
  function fn2() {
   console.log(a);
 }
 fn2();
}
fn1();


```
分为以下几步
+ 1.js执行把全局的上下文入栈。
+ 2.遇到fn1() 执行这个函数，创建该函数执行上下文，入栈，执行fn1。
+ 3.遇到fn2() 执行创建自己的执行上下文，入栈，执行fn2。
+ 4.fn2()在执行中并没有创建新的上下文，代码执行完毕，fn2出栈。
+ 5.fn2出战后执行fn1，fn1也不再创建新的上下文，代码执行完毕后，fn1出战。然后执行剩下的全局上下文。

### 五个重点
+ 单线程。
+ 同步执行。所有的执行上下文都得等到栈顶的执行之后才能顺序执行
+ 只有一个全局执行上下文。
+ 函数上下文是无限制的。
+ 每次函数被调用时都会创建新的执行上下文，包括调用自己.

### 再再看一个例子

```javascript
  function a1(){
        var count = 0;
        function a2(){
            count += 1;
            console.log(count)
        }
        return a2
    }
    
    var a3 = a1()
    a3()//1
    a3()//2
```
分为以下几步：

+ js执行，全局上下文入栈。
+ 执行到a1()，a1进栈，然后并没有执行其他函数，也就是并没有创建新的执行上下文，把a1的执行结果也就是reutrn了一个a2，赋予给了a3。按照我们的理解，此时没有创建新的执行上下文，那应该销毁对不对？这个先放着。
+ 执行a3()，a3执行的就是被return 出来的a2()，执行a2的时候需要打印一个count，如果是a1被销毁的情况下，那这个count是找不到的！！！因为a1被销毁了。所以a1是不可以被销毁的，因为如果a1被销毁，那a3依赖于a1就没法执行。这个a1返回的是一个函数，而这个函数里面引用了a1里面的count，如果清除a1，那么这个count就会寻找不到，所以这个时候内存分配了空间保留了a1。~

## 闭包？
+ 以上就是一个闭包。
+ 所有的回掉函数都是闭包。
+ 闭包就是能够读取其他函数内部变量的函数。

## 闭包的作用？

+ 我需要从外部引用函数内的局部变量！局部变量无法共享和长久的保存，而全局变量可能造成变量污染，所以我们希望有一种机制既可以长久的保存变量又不会造成全局污染。
+ 变量的值需要一直保存在内存里。


## 在各个浏览器下表现不同

```javascript
function a(){
    var a1 = 'a1'
    var b1 = 'b1'
    return function c(){
        console.log(a1)
    }
}
var fn = a()
fn()



```
+ 如果是Safari浏览器，那么上面你在console哪里打断点，会发现，闭包closure那，是有a1和b1，**尽管b1并没有使用！**
+ 如果是Chrome,那么就是你用了谁，谁才会出现在闭包closure里。

## 需要注意的点

+ 就算不return也会产生闭包！不要被你百度出来的文章迷惑！！！以下两个函数其实执行出来都会产生闭包！

```javascript
function a1(){
    var aa = 1
    function b(){
        console.log(aa)
    } 
    b()
}
a()

function a2(){
    var aa = 111
    function b2(){
        console.log(aa)
    } 
    return b2
}
var a3 = a2()
a3()

```

## 闭包的优势
###  减少全局变量。
例如：
```javascript
function a(){
    var n =1 
    n++ 
    console.log(n)
}
a()//2
a()
```
这个时候，我想让执行一次a，就加一次n，怎么办？我们脑海里，肯定会想，拉出去不就行了？

```javascript
var n =1 
function a(){
    
    n++ 
    console.log(n)
}
a()//2
a()

```

好吧，这样确实行，但是我又不想让他全局污染呢？这个时候我们就可以巧用闭包。

```javascript
function a(){
    var n = 1 
    function add(){
        n++
        console.log('我是add里的'+n)
    }
    return add
}

var add2 = a()
add2() //2
add2() //3


```
嗨呀！成了！ok了。

+ 减少参数
```javascript
function add(n){
    return function add2(max){
        return max+n
    }
}
var add3 = add(1)
add3(2)
```
+ 起到了封装的作用

## 闭包的注意点
+ 你只是引用了父类的变量，并没有复制父类的变量
+ 父类函数每次调用，都会产生新的闭包。
+ 